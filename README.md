Our model aims to provide a way for students to generate possible course plans that fulfill the CS concentration requirements. Further, we wanted our model to create “valid” course plans – that is, course plans in which course prerequisites are fulfilled and classes are assigned to specific semesters. This way, students intending to pursue CS can get an idea of all of the possible ways they can complete their degree.

To do this, our model represents semesters, courses, and prerequisites as sigs. A semester sig has a number (used to identify which semester this is) and a set of courses. A course sig has a set of prerequisites and a set of what we call equivalent courses (courses that cannot both be used for credit). A prerequisite sig is a set of courses – one of which must be taken to satisfy that prerequisite. A course can have multiple sets of prerequisites, which allows our model to account for courses that have multiple prerequisites that can be satisfied by different courses. One such example is cs0410, which requires cs0200 AND (cs0220, apma1650, apma1655, OR cs1410) AND (math0520, math0540, OR cs0530).

One of the key decisions we made in our model was to not use temporal Forge. This is why our semester sig has a number – this allows us to order semesters and ensure that prerequisites are fulfilled before a course is taken. We chose not to use temporal Forge for two reasons. First, we weren’t sure how we wanted to make lasso traces with our model. Second, we were worried that temporal Forge would struggle with the relationships between courses – prerequisites, equivalent courses, etc. However, our choice to not use temporal Forge limits our ability to track what courses a plan has used for which requirements. For example, if you take cs1410 to fulfill the AI intermediate requirement, you cannot also count that course as part of the thousand-level course requirements. However, tracking this is quite difficult in relational Forge, since we cannot specify what gets added to our set of courses used for the foundation requirements in each semester. We settled on a somewhat underconstrained approach that simply forces whichever course was used for a particular requirement to be in a specific set, and then check in other requirements that the course satisfying that requirement is not being used for other requirements. This prevents double-dipping, but also disallows gaining credit for more than one course satisfying a particular requirement. For example, if a plan has cs0410 and cs1470 in the same semester, both would be treated as fulfilling the AI foundation requirement, and so the plan would effectively get just one credit for these two courses (as cs1470 could then not be used for the additional course or thousand level course requirement).

Due to us being a group of two and the complexities in translating courses to our model – defining sigs, prerequisite sets, and equivalent courses – we have not modeled every course in the CS department (notably, we only model 10 capstone courses). We also haven’t modeled a majority of the non-CS courses that can be used for CS concentration credit. This was an intentional choice, and one we had noted in our proposal, but it definitely limits what our model can do, the pathways for completion it can create, and the students it can serve. 

Another limitation of our model lies in the limitations of Forge itself – integer bitwidth. One feature we support (technically) is letting users specify that they wanted their courses spread out or that they wanted to finish their degree as fast as possible. We implemented this by either limiting the number of courses included per semester or specifying that semesters beyond some certain semester number should have no courses (since our model includes only courses used for the CS concentration). This works in some instances – for example, limiting the number of CS courses in a semester to no more than three generates instances obeying this restriction. However, for “harsher” limits, like no more than 1 or 2 CS courses in a semester, the bitwidth of Forge, and the wrap-around behavior of Ints rears its head. For example, one semester might have 20 courses. Upping the bitwidth to 8 fixes many of these issues, but also increases runtime by quite a bit. So, while this feature exists, using it takes a bit of extra patience.

Finally, the last major limitation of our model is that we don’t enforce any notion of “reasonableness” on the course plans we generate. While this helps in creating a diverse mix of plans, it also leads to plans that many advisors might recommend not following, such as plans with 5 thousand-level CS courses in one semester, but no CS courses in another. The instances generated can therefore be a bit nonsensical. That said, one person’s definition of a reasonable course plan may not align with another person’s, so this could also be considered a strength of the model.

That said, our model ended up being more fully featured than we expected. One of our reach goals was supporting the AB vs. ScB requirements, which is something we implemented. We also were able to add in consideration of fall vs spring semesters. This makes our model a lot more helpful in creating course plans that actually represent what a student might do.

Some interesting things we discovered with our model: it is possible, at least in our model, to finish the CS ScB requirements in just four semesters. This is true even if you force the plan to include cs1710! For the AB, you need just 3 semesters to complete a CS degree at Brown, so to any second-semester juniors: join us.

To understand our model’s output, it’s best to use the custom div visualizer. Sterling’s numbers for the semester schedule atoms don’t always align with the actual semNumber assigned (e.g. SemesterSchedule0 might have a semNumber that is not zero). This custom visualizer shows, in order for each of the standard eight semesters, which courses are included in the current instance. If no courses are assigned to that semester, the visualizer will show “No courses.” We note here that our model is only modeling how to complete the CS degree requirements, so any empty spaces are spots a student could fill with other courses unrelated to finishing their CS degree. Also, before stepping to the next instance, be sure to clear the visualizer div (either through the browser dev tools or by clicking a non div visualizer option and then going back to div). 